\chapter{Аналитический раздел}

\section{Постановка задачи}

В соответствии с темой на курсовую работу по дисциплине <<Операционные системы>> необходимо разработать загружаемый модуль ядра Linux для регулировки уровня громкости клавиатурой с возможностью использования заданной шкалы настроек.

Для решения поставленной задачи необходимо:
\begin{itemize}
    \item провести анализ способов обработки прерываний;
    \item провести анализ существующих аудио подсистем;
    \item разработать алгоритмы и описать структуру разрабатываемого ПО;
    \item разработать ПО, предоставляющее заявленную функциональность;
    \item исследовать разработанное ПО.
\end{itemize}

\section{Анализ способов обработки прерываний}

Одной из основных задач компьютера является обеспечение связи и обмена данными с внешними устройствами. В системах, использующих монолитное ядро, все системные операции основаны на прерываниях. Прерывания делятся на три категории: системные вызовы, исключения и аппаратные прерывания. Аппаратные прерывания генерируются такими устройствами, как клавиатура, мышь или таймер, и являются асинхронными по своей природе, то есть они не зависят от других текущих процессов в системе.

Существует два типа аппаратных прерываний: быстрые и медленные. В современных системах Linux единственным быстрым прерыванием является прерывание таймера, которое является привилегированным и обрабатывается от начала до конца без какой-либо другой обработки, происходящей в процессоре. В это время все прерывания, включая прерывания других процессоров в системе, отключены. Обработчики прерываний должны выполняться как можно быстрее, чтобы минимизировать прерывание.

Все остальные прерывания являются медленными. Они состоят из двух частей --- верхней половины и нижней половины. Верхняя половина выполняет начальную работу по настройке, необходимую для прерывания, в то время как нижняя половина выполняет фактическую обработку прерывания. Верхняя половина подготавливает действия, необходимые для обработки прерывания, и прекращает взаимодействие с контроллером прерывания после выполнения своих задач. Это позволяет системе полностью разрешить прерывание и восстановить предыдущую маску прерывания. Нижняя половина выполняется при разрешенных прерываниях.

Веделяют три типа нижных половин:
\begin{itemize}
    \item soft IRQ;
    \item тасклеты;
    \item очереди работ.
\end{itemize}

Тасклет --- частный случай реализации soft IRQ. Обработчик одного тасклета выполняется только на одном процессоре, на котором выполнялась верхняя половина прерывания. Их можно создавать как статически, так и динамически.

Тасклеты считаются устаревшим механизмом, поэтому в современных
версиях ядра их не используют \cite{tasklet}.

В отличие от тасклетов, очереди работ могут блокироваться, поэтому необязательно должны быть неделимыми. Управление очередями работ реализовано иначе, чем у тасклетов. В ядре описаны структуры, описывающие работу, выполняемую обработчиком действия, очередь работ, поток ядра, выполняющий работу, пул рабочих, а также отношения между пулом рабочих и очередью работ.

Очереди работ могут выполняться на разных процессорах и имеют большие задержки, в отличие от тасклетов, которые выполняются через небольшой промежуток времени после того, как были запланированы. 

Очередь работ описывается структурой struct workqueue\_struct и приведена в листингах \ref{lst:workqueue_struct1}--\ref{lst:workqueue_struct2} \cite{workqueuec}.

\begin{lstlisting}[caption={Структура struct workqueue\_struct (часть 1)} \label{lst:workqueue_struct1}]
struct workqueue_struct {
	struct list_head	pwqs;		/* WR: all pwqs of this wq */
	struct list_head	list;		/* PR: list of all workqueues */
	struct mutex		mutex;		/* protects this wq */
\end{lstlisting}

\begin{lstlisting}[caption={Структура struct workqueue\_struct (часть 2)} \label{lst:workqueue_struct2}]
	int			work_color;	/* WQ: current work color */
	int			flush_color;	/* WQ: current flush color */
	atomic_t		nr_pwqs_to_flush; /* flush in progress */
	struct wq_flusher	*first_flusher;	/* WQ: first flusher */
	struct list_head	flusher_queue;	/* WQ: flush waiters */
	struct list_head	flusher_overflow; /* WQ: flush overflow list */
	struct list_head	maydays;	/* MD: pwqs requesting rescue */
	struct worker		*rescuer;	/* MD: rescue worker */
	int			nr_drainers;	/* WQ: drain in progress */
	int			saved_max_active; /* WQ: saved pwq max_active */
	struct workqueue_attrs	*unbound_attrs;	/* PW: only for unbound wqs */
	struct pool_workqueue	*dfl_pwq;	/* PW: only for unbound wqs */
#ifdef CONFIG_SYSFS
	struct wq_device	*wq_dev;	/* I: for sysfs interface */
#endif
#ifdef CONFIG_LOCKDEP
	char			*lock_name;
	struct lock_class_key	key;
	struct lockdep_map	lockdep_map;
#endif
	char			name[WQ_NAME_LEN]; /* I: workqueue name */
	/*
	 * Destruction of workqueue_struct is RCU protected to allow walking
	 * the workqueues list without grabbing wq_pool_mutex.
	 * This is used to dump all workqueues from sysrq.
	 */
	struct rcu_head		rcu;
	/* hot fields used during command issue, aligned to cacheline */
	unsigned int		flags ____cacheline_aligned; /* WQ: WQ_* flags */
	struct pool_workqueue __percpu *cpu_pwqs; /* I: per-cpu pwqs */
	struct pool_workqueue __rcu *numa_pwq_tbl[]; /* PWR: unbound pwqs indexed by node */
};
\end{lstlisting}

Для описания работ в очереди определена структура struct work\_struct, которая приведена в листинге \ref{lst:work_struct} \cite{workqueueh}.

\begin{lstlisting}[caption={Структура struct work\_struct} \label{lst:work_struct}]
struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
#ifdef CONFIG_LOCKDEP
	struct lockdep_map lockdep_map;
#endif
};
\end{lstlisting}

Таким образом, при помощи очередей работ можно описать собственный обработчик аппаратных прерываний и изменять функциональность внешних устройств.

\section{Анализ аудио подсистем}

Аудио драйверы реализованы в виде модулей ядра и взаимодействуют со звуковой картой через специльные фреймворки, которые обеспечивают последовательный и единообразный интерфейс для звуковых драйверов, облегчая приложениям доступ к аудиоустройствам. 

Когда приложение запрашивает воспроизведение звука, запрос отправляется в соответствующий фреймворк, который взаимодействует со звуковым драйвером. Затем драйвер преобразует цифровые аудиоданные в аналоговые сигналы и отправляет их на звуковую карту для вывода.

Входящий звук обрабатывается аналогичным образом. Звуковая карта преобразует входящие аналоговые сигналы в цифровые данные и отправляет их драйверу, который затем передает их в фреймворк для обработки. Затем  приложение, которое их запросило, получает обработанные данные.

Процесс преобразования цифровых аудиоданных в аналоговые сигналы и наоборот известен как цифро-аналоговое преобразование (ЦАП) и аналого-цифровое преобразование (АЦП) соответственно. Качество этих преобразований зависит от возможностей звуковой карты и драйвера.

Наиболее распространенные фреймворки для работы со звуком:
\begin{enumerate}
    \item Open Sound System;
    \item Advanced Linux Sound Architecture;
    \item JACK Audio Connection Kit.
\end{enumerate}

\subsection{Open Sound System}

Open Sound System (OSS) --- это старейшая из рассматриваемых аудио подсистем, разработанная для переносимости и обеспечения единого интерфейса для приложений, связанных со звуком. Это проект с открытым исходным кодом, который доступен для широкого спектра компьютерных операционных систем, включая Linux, FreeBSD, Solaris и MacOS \cite{oss}.

К основным особенностям OSS относятся:

\begin{itemize}
    \item поддержка широкого спектра аудиоаппаратуры, включая звуковые карты и USB-аудиоустройства;
    \item поддержка широкого спектра аудиоформатов, включая WAV, AIFF, MP3, Ogg Vorbis и FLAC;
    \item поддержка широкого спектра аудиоприложений, включая аудиоплееры, аудиоредакторы и программы записи звука;
    \item поддержка многоканального звука и объемного звучания;
    \item Поддержка аудио с низкой задержкой, что позволяет использовать аудио в реальном времени в таких приложениях, как синтез музыки и игры;
    \item поддержка аудиоплагинов, позволяющих использовать эффекты и виртуальные инструменты сторонних производителей;
    \item поддержка микширования звука, позволяющая смешивать несколько источников звука;
    \item поддержка маршрутизации аудиосигналов, позволяющая передавать аудиосигналы между приложениями;
    \item поддержка потокового аудио, позволяющая передавать аудио по сети;
    \item поддержка захвата аудио, позволяющая захватывать аудио из различных источников;
    \item поддержка аудиоэффектов, позволяющая использовать эффекты и виртуальные инструменты сторонних производителей;
    \item поддержка визуализации аудио, позволяющая визуально представлять аудиосигналы.
\end{itemize}

\subsection{Advanced Linux Sound Architecture}

Advanced Linux Sound Architecture (ALSA) --- это программная структура и часть ядра Linux, которая предоставляет интерфейс для драйверов устройств звуковых карт \cite{alsa}.

ALSA обеспечивает поддержку всех типов аудиоустройств, включая цифровые, MIDI и аналоговые, а также поддержку расширенных функций, таких как обработка эффектов в реальном времени, 3D аудио и объемный звук.

Фреймворк предоставляет набор API, которые позволяют приложениям получать доступ к функциям звуковой карты, таким как микшер, эквалайзер и MIDI-порты. Эти API включают функции для настройки и управления звуковой картой, воспроизведения и записи звука, а также управления аудиоэффектами.

Advanced Linux Sound Architecture также обеспечивает поддержку широкого спектра аудиоформатов, включая WAV, MP3, OGG и MIDI, более того существует поддержка различных аудиоэффектов, включая реверберацию, эхо, хорус, искажение и аппаратное микширование, которое позволяет смешивать несколько аудиопотоков.

\subsection{JACK Audio Connection Kit}

JACK Audio Connection Kit (JACK) --- это система подключения и обработки аудио для Linux, MacOS и Windows. Это аудиосервер с низкой задержкой, который позволяет нескольким приложениям подключаться к одному аудиоустройству и обмениваться аудиосигналами между ними. Он подходит для создания сложных аудиоустановок, таких как те, что используются в студиях звукозаписи, системах живого звука и других профессиональных аудиоприложениях \cite{jack}.

JACK разработан для простоты использования и обеспечения максимально возможного качества звука. Он поддерживает широкий спектр аудиоформатов, включая 16-- и 24--битное аудио с частотой дискретизации до 192 кГц. Он также поддерживает различные аппаратные средства ввода/вывода аудио, включая USB, FireWire и Ethernet.

Фреймвор позволяет направлять аудиосигналы между приложениями, а также на внешнее оборудование. Он поддерживает широкий спектр плагинов для обработки звука, таких как эквалайзеры, компрессоры, лимитеры и задержки, а также множество других эффектов.

Является программным обеспечением с открытым исходным кодом и доступен бесплатно. Его поддерживает большое сообщество пользователей и разработчиков, которые постоянно работают над улучшением программы и добавлением новых функций.

JACK работает по принципу архитектуры сервер--клиент, где сервер JACK управляет аудиоустройствами и приложениями, а клиенты JACK используют сервер для подключения к аудиоустройствам и взаимодействия с другими приложениями. 

Сервер JACK предоставляет высококачественный аудиопоток с низкой задержкой, синхронизированный с системными часами. Этот поток делится на аудиокадры, каждый из которых представляет собой небольшую единицу аудиоданных, передаваемых между клиентами JACK.

Клиентами JACK могут быть аудиоприложения или плагины, такие как синтезаторы, сэмплеры, процессоры эффектов и цифровые аудио рабочие станции (DAW). JACK позволяет подключать эти приложения в режиме реального времени, обеспечивая модульный и гибкий подход к обработке звука.

Для функционирования и работы необходимо установить сервер и клиенты JACK. После установки вы можете запустить сервер JACK и запустить клиенты JACK, которые автоматически подключатся к серверу. Графический инструмент JACK Patchbay упрощает маршрутизацию аудиосигналов между клиентами.

\subsection{Сравнение рассмотренных решений}

В соответсвии с поставленной задачей необходимо разработать загружаемый модуль ядра Linux, а JACK Audio Connection Kit позволяет работать только в пространстве пользователя, соответственно его использование в данной работе невозможно.

В таблице \ref{tabular:comparison} представленно сравнение OSS и ALSA.

\clearpage

\begin{table}[h!]
	\centering
	\caption{\label{tabular:comparison} Сравнение OSS и ALSA}
\begin{tabular}{|l|l|}
\hline
\textbf{Преимущества OSS} & \textbf{Преимущества ALSA} \\ \hline
Поддержка старых устройств & Поддержка современных устройств \\ \hline
Кроссплатформенность & Linux ориентированность \\ \hline
Более простое API & Больший функционал \\ \hline
 & Лучшая поддержка USB устройств \\ \hline
 & Лучшая поддержка MIDI устройств \\ \hline
 & Лучшая поддержка Bluetooth устройств \\ \hline
\end{tabular}
\end{table}

\section*{Выводы}

В данном разделе были рассмотрены способы обработки прерываний от внешних устройств, а также основные аудио подсистемы.

Для реализации поставленной задачи и отслеживания нажатых клавиш на клавиатуре необходимо разработать загружаемый модуль ядра, в котором будут перехватываться прерывания клавиатуры.

Для обработки прерываний выбраны очереди работ, так как для добавления нового softIRQ требуется перекомпиляция ядра, а использование такслетов нецелесообразно, так как они признаны устаревшими и в будущем будут выведены из ядра.

В результате сравнительного анализа аудио подсистем выбран подход с использованием фреймворка ALSA ввиду большого функционала и широкой совместимости с современными звуковыми устройствами.